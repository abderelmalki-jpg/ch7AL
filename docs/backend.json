{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the Hanout Price application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user entity."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "name": {
          "type": "string",
          "description": "User's display name."
        },
        "phone": {
          "type": "string",
          "description": "User's phone number."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the user account was created.",
          "format": "date-time"
        },
        "points": {
          "type": "number",
          "description": "User's accumulated points."
        },
        "badges": {
          "type": "array",
          "description": "An array of badge identifiers awarded to the user.",
          "items": {
            "type": "string"
          }
        },
        "contributions": {
          "type": "number",
          "description": "Number of contributions made by the user."
        },
        "language": {
          "type": "string",
          "description": "Preferred language of the user."
        }
      },
      "required": [
        "id",
        "email",
        "name",
        "createdAt"
      ]
    },
    "Product": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Product",
      "type": "object",
      "description": "Represents a product listed in the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the product entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the product."
        },
        "brand": {
          "type": "string",
          "description": "Brand of the product."
        },
        "category": {
          "type": "string",
          "description": "Category of the product."
        },
        "barcode": {
          "type": "string",
          "description": "Barcode of the product."
        },
        "description": {
          "type": "string",
          "description": "Description of the product."
        },
        "imageUrl": {
          "type": "string",
          "description": "URL of the product image.",
          "format": "uri"
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the product was added.",
          "format": "date-time"
        },
        "updatedAt": {
          "type": "string",
          "description": "Timestamp indicating when the product was last updated.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "name",
        "category",
        "barcode"
      ]
    },
    "Price": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Price",
      "type": "object",
      "description": "Represents a price entry for a product at a specific store.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the price entry."
        },
        "productId": {
          "type": "string",
          "description": "Reference to Product. (Relationship: Product 1:N Price)"
        },
        "storeId": {
          "type": "string",
          "description": "Reference to Store. (Relationship: Store 1:N Price)"
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Price)"
        },
        "price": {
          "type": "number",
          "description": "The price of the product."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the price was recorded.",
          "format": "date-time"
        },
        "verified": {
          "type": "boolean",
          "description": "Indicates if the price has been verified."
        },
        "reports": {
          "type": "number",
          "description": "Number of reports against this price."
        }
      },
      "required": [
        "id",
        "productId",
        "storeId",
        "userId",
        "price"
      ]
    },
    "Store": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Store",
      "type": "object",
      "description": "Represents a physical store location.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the store entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the store."
        },
        "latitude": {
          "type": "number",
          "description": "Latitude of the store's location."
        },
        "longitude": {
          "type": "number",
          "description": "Longitude of the store's location."
        },
        "address": {
          "type": "string",
          "description": "Address of the store."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the store was added.",
          "format": "date-time"
        },
        "rating": {
          "type": "number",
          "description": "Average rating of the store."
        },
        "totalRatings": {
          "type": "number",
          "description": "Number of ratings received by the store."
        }
      },
      "required": [
        "id",
        "name",
        "latitude",
        "longitude"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information. Path-based ownership for simple security rules.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/products/{productId}",
        "definition": {
          "entityName": "Product",
          "schema": {
            "$ref": "#/backend/entities/Product"
          },
          "description": "Stores product information.  The top-level collection simplifies listing and searching products.",
          "params": [
            {
              "name": "productId",
              "description": "The unique identifier of the product."
            }
          ]
        }
      },
      {
        "path": "/prices/{priceId}",
        "definition": {
          "entityName": "Price",
          "schema": {
            "$ref": "#/backend/entities/Price"
          },
          "description": "Stores price entries for products. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "priceId",
              "description": "The unique identifier of the price entry."
            }
          ]
        }
      },
      {
        "path": "/stores/{storeId}",
        "definition": {
          "entityName": "Store",
          "schema": {
            "$ref": "#/backend/entities/Store"
          },
          "description": "Stores store information. The top-level collection simplifies listing and searching stores.",
          "params": [
            {
              "name": "storeId",
              "description": "The unique identifier of the store."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to address the error reported (connection issues) by ensuring efficient data retrieval and a scalable architecture. It leverages denormalization and structural segregation to optimize performance and simplify security rules. The design focuses on creating a structure that's easy to debug and maintain, aligning with the project's goals of community-driven price comparison in local 'hanouts'.\n\n1.  **Authorization Independence**:  Denormalization is used to eliminate `get()` calls in security rules.  For example, the `userId` is included in the `prices` collection to directly associate a price with a user. This allows security rules to validate user ownership of price entries without needing to perform additional reads to the `users` collection.\n\n2.  **Structural Segregation**: The structure segregates data based on access patterns. User-specific data (like user profiles) are stored under the `/users/{userId}` path, while global data (products, stores) reside in top-level collections. This simplifies security rules, as each collection has a clear and consistent security posture.\n\n3.  **Access Modeling**:  Path-based ownership is employed for user-related data (e.g., `/users/{userId}`). This is the most secure and efficient way to manage data owned by individual users.  Membership maps are not explicitly needed in this design, because all data is owned and the global roles were not defined in the request.\n\n4.  **QAPs (Rules are not Filters)**:  The structure supports secure `list` operations by ensuring that list queries do not require filtering based on user roles or permissions.  The separation of user-owned data into user-specific subcollections allows for efficient and secure listing of a user's resources.\n\n5.  **Invariants**:  The structure supports data integrity by enforcing clear ownership and timestamp management.  The `createdAt` and `updatedAt` fields in various entities ensure that data creation and modification times are tracked consistently.  This is important for auditing and maintaining data consistency.\n\nThe Firestore paths provided below reflect this design, emphasizing simplicity, security, and scalability."
  }
}